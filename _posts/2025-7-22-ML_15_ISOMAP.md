---



title: 机器学习（15）等距特征映射——Isometric Mapping, ISOMAP
tags: ML Dimensionality_Reduction
typora-root-url: ./..
---

思想：MDS算法在流形结构上的一种应用，也是希望原始空间样本点之间的距离在新空间上保持不变，但是IsoMap使用的是测地距离。一种非线性降维算法，主要目的是保留数据的全局几何结构。

<!--more-->

##### 1.流行学习——Manifold Learning

1.1 什么是流形？

流形是局部具有欧几里得空间性质的拓扑空间。换句话说，流形是一个可以在局部范围内近似为欧几里得空间的空间。

- 欧几里得空间（Euclidean space） 是一类特殊的向量空间，它允许讨论长度、夹角等几何性质。

- n维欧几里得空间表示为$\mathbb{R}^n$是由所有n元有序实数元组构成的空间。

二维欧几里得空间$ \mathbb{R}^2$：由所有形如(x,y)的有序对组成，可以表示平面上的所有点。

三维欧几里得空间$ \mathbb{R}^3 $：由所有形如(x,y,z)的有序三元组组成，用于描述物理世界中的空间位置。

- 性质

距离：欧几里得空间中两点的距离可以通过欧几里得距离公式计算$d(\textbf{a},\textbf{b})=\sqrt{\sum_{i=1}^n(a_i-b_i)^2}$

角度：两个向量之间的角度可以通过它们之间的点积和模长来计算$cos\ \theta = \frac{\textbf{a} \cdot \textbf{b}}{\|\textbf{a}\| \|\textbf{b}\|}$

内积空间：欧几里得空间是一个内积空间，其内积定义为两向量的点积

1.2 什么是流形学习？

流形学习的观点：认为我们所能观察到的数据实际上是由一个低维流形映射到高维空间的。由于数据内部特征的限制，一些高维中的数据会产生维度上的冗余，实际上这些数据只要比较低的维度就能唯一的表示。

流形学习的基本假设是：尽管数据可能在高维空间中呈现，但是它们实际上分布在一个低维的流形上。这个流形是数据的真实结构，它捕捉了数据中的内在关系和模式。

一个形象的流形降维过程如下图。我们有一块卷起来的布，我们希望将其展开到一个二维平面，我们希望展开后的布能够在局部保持布结构的特征，其实也就是将其展开的过程，就想两个人将其拉开一样。

![](/assets/images/ISOMAP/one.png)

##### 2.ISOMAP

2.1 测地距离

在MDS中，求取距离使用的是欧式距离，但在流形空间上，欧氏距离不一定是数据点之间的真实距离，举个形象的例子就是，二楼有个小明，三楼有个小红，小明要去找小红，不可能用欧式距离飞上三楼，肯定要去爬楼梯绕一圈。

那么小明爬楼找小红所经过的距离，就是测地距离，也就是两个点在先有路径下真实可达的距离（真实距离）。

2.2 衡量测地距离

测地距离理解了，但是这种距离应该怎么求解？要怎么计算绕一圈的这种路径距离？

这里举一个上课传纸条的例子，你想从最后一排传纸条给第一排的小红，如果你直接走过去或者把纸条扔过去，肯定会被老师发现，所以你想要通过你周围的人将纸条传递过去，你周围的人被称为你的邻居。你传给你的邻居后，你的邻居传给邻居的邻居，最后传到了小红手里，从你到你的邻居再到邻居的邻居，最后到小红，就是一段距离。

你肯定希望传的越快越好，所以你想要找到一条最短的传递路线，这也就是ISOMAP的思想。

班级所有人都可以看成数据点，想要知道任意两个点的测地距离，通过寻找每个点的k个邻居，构造距离矩阵，找到最短的那条路径，就得到了测地距离。

图1蓝色实现是期望实现，图2是ISOMAP实现，图3是降维后的对比。虽然不能完全计算真实距离，但是能近似获取真实距离。

![](/assets/images/ISOMAP/two.png)

![](/assets/images/ISOMAP/three.png)

![](/assets/images/ISOMAP/four.png)

##### 3.图的基础概念

3.1 图

图(Graph)通常表示为:

$$G=(V,E)$$

其中，G表示个图，V是图G中顶点的集合，E是图G中边的集合。

V(G)：顶点的有穷非空集合。

E(G)：顶点之间边的集合。

若$V= \lbrace v_1, v_2,...,v_n \rbrace$，则用$\vert V \vert$表示图G中顶点的个数，也称图G的阶.

$E= \lbrace (u, v) \vert u∈V, v∈V \rbrace$，用$\vert E \vert$表示图G中边的条数。

3.2 有向图

若E是有向边(也称弧)的有限集合时，则图G为有向图。弧是顶点的有序对，记为<v, w>，其中v,w是顶点，v称为弧尾，w称为弧头，<v,w>称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。

![](/assets/images/ISOMAP/five.png)

图(a)所示的有向图$ G_1$可表示为

$$ G_1 = (V_1,E_1)$$

 $$V 1 = { 1 , 2 , 3 } V_1=\{1,2,3\}$$

$$E_1=\{<1,2>,<2,1>,<2,3>\}$$

3.3无向图

若E是无向边(简称边)的有限集合时，则图G为无向图。边是顶点的无序对，记为(v, w)或(w,v),因为(v,w)=(w,v), 其中v,w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v, w相关联。

![](/assets/images/ISOMAP/six.png)

图(b)所示的无向图$G_2$可表示为

$$G_2=(V_2,E_2)$$

$$V_2=\{1,2,3,4\}$$

$$ E_2=\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}$$

3.4 边的权重

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图。

3.5 邻接矩阵

设图G有n个顶点，则邻接矩阵A是一个n*n的方阵，定义为:

$$A[i][j] = \left\{\begin{array}{l}
1, \text { 若 }(v_i, v_j)\text {或}<v_i, v_j>\text {是}E(G)\text {中的边} \\
0, \text { 若 }(v_i, v_j)\text {或}<v_i, v_j>\text {不是}E(G)\text {中的边}
\end{array}\right.$$

3.6 带权邻接矩阵

$$A[i][j] = \left\{\begin{array}{l}
W_{ij}, \text { 若 }(v_i, v_j) \in E \text {或} <v_i, v_j> \in E \\
0, \text { 若 } i=j \\
\infty, otherwish
\end{array}\right.$$

##### 4.最短路径算法（只介绍怎么用，因为这是机器学习笔记，不是数据结构笔记）

4.1 Dijkstra算法

Dijkstra（迪杰斯特拉）算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。

例子，带权图，找到A与其他点的最短路径：

![](/assets/images/ISOMAP/senven.png)

| 步骤 | S集合（已选节点） | U集合（未选节点） |
| ---- | ----------------- | ----------------- |
| 1 | 从A开始，此时 S= \<A \> <br />此时最短路径A$\to$ A=0<br />以A为中间点，从A开始找 | U=<B、C、D、E、F><br />A $\to$ B=6<br />A $\to$ C=3<br />A $\to$ 其他U中的顶点=$\infty$<br />发现A $\to$ C=3权值为最短 |
| 2 | 选入C，此时 S= <A、C><br />此时最短路径A$\to$ A=0，A$\to$ C=3<br />以C为中间点，从A$\to$ C=3这条最短路径开始找 | U=<B、D、E、F><br />A $\to$ C $\to$ B=5（比上面第一步的A $\to$ B=6短）<br />A $\to$ C $\to$ D=6<br />A $\to$ C $\to$ E=7<br />A $\to$  C $\to$其他U中的顶点=$\infty$<br />发现A $\to$ C $\to$ B=5权值为最短 |
| 3 | 选入B，此时 S= <A、C、B><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5<br />以B为中间点，从A$\to$ C$\to$ B=5这条最短路径开始找 | U=<D、E、F><br />A $\to$ C $\to$ B $\to$ D=10（比上面第二步的A $\to$ C $\to$ D=6长）<br />此时到D的权值改为A $\to$ C $\to$ D=6<br />A $\to$ C $\to$ B $\to$其他U中的顶点=$\infty$<br />发现A $\to$ C $\to$ D=6权值为最短 |
| 4 | 选入D，此时 S= <A、C、B、D><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5，A $\to$ C $\to$ D=6<br />以D为中间点，从A $\to$ C $\to$ D=6这条最短路径开始找 | U=<E、F><br />A $\to$ C $\to$ D $\to$ E=8（比上面第二步的A $\to$ C $\to$ E=7长）<br />此时到E的权值改为A $\to$ C $\to$ E=7<br />A $\to$ C $\to$ D $\to$F=9<br />发现A $\to$ C $\to$ E=7权值为最短 |
| 5 | 选入E，此时 S= <A、C、B、D、E><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5，A $\to$ C $\to$ D=6，A $\to$ C $\to$ E=7<br />以E为中间点，从A $\to$ C $\to$ E=7这条最短路径开始找 | U=<F><br />A $\to$ C $\to$ E $\to$F=12（比上面第四步的A $\to$ C $\to$ D $\to$F=9长）<br />此时到F的权值改为A $\to$ C $\to$ D $\to$F=9<br /> />发现A $\to$ C $\to$ D $\to$F=9权值为最短 |
| 6 | 选入F，此时 S= <A、C、B、D、E、F><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5，A $\to$ C $\to$ D=6，A $\to$ C $\to$ E=7、A $\to$ C $\to$ D $\to$F=9 | U集合已空，查找完毕。 |

4.2 Floyd算法

解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题。

思想：从任意节点i到任意节点j的最短路径只有2种可能：1是直接从i到j，2是从i经过若干个节点k到j。

假设$d_{ij}$为节点i到节点j的最短路径的距离，对于每一个节点k，我们检查$d_{ik} + d_{kj} < d_{ij}$是否成立。

如果成立，证明从i到k再到j的路径比i直接到j的路径短，设置$d_{ik} + d_{kj} = d_{ij}$，当遍历完所有节点k，$d_{ij}$中记录的便是i到j的最短路径的距离。

![](/assets/images/ISOMAP/eight.png)

简单解释一下，白色是更新的地方，以第三张图为例，因为允许经过节点1，所以3先到1再到2，便有了新的距离，以此类推。

##### 5.算法流程

- 构建邻接图：基于输入空间中流形上的邻近点对之间的欧式距离，选取每个样本点距离最近的 K 个点，将这些邻近点用边连接，把流形构建为一个反映邻近关系的带权流通图 G。
- 计算所有点对之间的最短路径：通过计算邻接图 G 上任意两点之间的最短路径，来逼近流形上的测地距离矩阵。
- 构建低维坐标向量：将得到的图距离矩阵代替MDS算法中高维距离矩阵，之后使用MDS求解低维坐标向量。

##### 6.ISOMAP优缺点

优点：

- 捕捉非线性结构：相比PCA等线性降维方法，Isomap能有效处理非线性数据(如瑞士卷、人脸图像等)，揭示高维数据背后的低维流形。
- 保持全局几何结构：通过测地线距离，Isomap不仅保留局部关系，还能反映数据的全局几何特征。

缺点：

- 对参数敏感，邻接图构建依赖经验，参数调优需大量实验，缺乏通用标准。例如K值的选择，过小可能导致最短路径计算失效，过大可能引入非流形区域的噪声点，破坏局部线性假设。
- 计算复杂度高，多源最短路径算法时间复杂度为O($n^3$)，难以处理大规模数据。
- 高维数据中的噪声可能导致邻接图误连（将噪声点纳入近邻），而离群点会显著扭曲测地距离计算。例如，一个离群点可能被错误地纳入多个样本的近邻，导致最短路径 “短路”，破坏流形的全局结构。
- ISOMAP 假设数据分布在单连通、非交叉的低维流形上。若流形存在自交叉（如 “8 字形” 流形）或非凸结构（如闭合环面），邻接图可能无法准确反映流形的拓扑结构，导致最短路径计算错误，降维结果失真。

~~~
# 手写实现（Floyd）
import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets

# 返回任意两个点之间欧氏距离
def cal_pairwise_dist(x):
    N,D = np.shape(x)
    
    dist = np.zeros([N,N])
    
    for i in range(N):
        for j in range(N):
            dist[i,j] = np.sqrt(np.dot((x[i]-x[j]),(x[i]-x[j]).T))
            
    return dist
    
# Floyd算法求解最短路径
def floyd(D, n_neighbors=15):
    # 定义无穷大
    Max = np.max(D) * 1000
    n1, n2 = D.shape
    k = n_neighbors
    D1 = np.ones((n1, n1)) * Max
    D_arg = np.argsort(D, axis=1)
    for i in range(n1):
        D1[i, D_arg[i, 0:k+1]] = D[i, D_arg[i, 0:k+1]]
    for k in range(n1):
        for i in range(n1):
            for j in range(n1):
                if D1[i, k] + D1[k, j] < D1[i, j]:
                    D1[i, j] = D1[i, k] + D1[k, j]
    return D1

# 经典MDS算法
def mds(dist, n_dims=2):
    """
    实现经典MDS降维
    
    参数:
    D_sq: 距离平方矩阵，形状为(n_samples, n_samples)
    n_dims: 降维后的维度
    
    返回:
    Z: 降维后的矩阵，形状为(n_samples, n_dims)
    """
    # 步骤1: 获取样本数量
    n = dist.shape[0]
          
    # 步骤2: 构造中心化矩阵H
    H = np.eye(n) - np.ones((n, n)) / n
    
    # 步骤3: 计算双中心化后的内积矩阵B
    B = -0.5 * H @ dist @ H
    
    # 步骤4: 对B进行奇异值分解(SVD)
    U, Sigma, Vt = np.linalg.svd(B)
    Sigma = np.maximum(Sigma, 0)
    
    # 步骤5: 选取前n_components个奇异值和对应的特征向量
    Sigma_k = np.diag(np.sqrt(Sigma[:n_dims]))
    U_k = U[:, :n_dims]
    
    # 步骤6: 计算低维坐标
    Z = U_k @ Sigma_k
    
    return Z

# ISOMAP算法（修复函数调用参数名错误）
def IsoMap(X, n=2, n_neighbors=30):
    dist = cal_pairwise_dist(X)
    D_floyd = floyd(dist, n_neighbors)
    D_floyd = D_floyd ** 2
    data_n = mds(D_floyd, n_dims=n)
    return data_n

# datasets数据集
X, color = datasets.make_swiss_roll(n_samples=1500, noise=0.01, random_state=42)

# 应用ISOMAP降维
data = IsoMap(X, 2, 10)

fig = plt.figure(figsize=(14,7))

ax1 = fig.add_subplot(1, 2, 1, projection='3d')
ax1.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)
ax1.set_title("make_swiss_roll")
ax1.view_init(4, -75)  # 调整视角

plt.subplot(122)
plt.title("IsoMap")
plt.scatter(data[:, 0], data[:, 1], c = color, cmap=plt.cm.Spectral)
plt.show()
~~~

~~~
# 手写实现（Dijkstra）
import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets

# 返回任意两个点之间欧氏距离
def cal_pairwise_dist(x):
    N,D = np.shape(x)
    
    dist = np.zeros([N,N])
    
    for i in range(N):
        for j in range(N):
            dist[i,j] = np.sqrt(np.dot((x[i]-x[j]),(x[i]-x[j]).T))
            
    return dist

# Dijkstra算法求解单源最短路径
def dijkstra(adj_matrix, start):
    """
    实现Dijkstra算法求解单源最短路径
    
    参数:
    adj_matrix: 邻接矩阵，表示图中各节点间的距离
    start: 起始节点索引
    
    返回:
    distances: 从起始节点到所有其他节点的最短距离
    """
    n = adj_matrix.shape[0]
    # 初始化距离数组，无穷大表示不可达
    distances = np.full(n, np.inf)
    # 起点到自身的距离为0
    distances[start] = 0
    # 记录已访问的节点
    visited = np.full(n, False)
    
    for _ in range(n):
        # 找到当前未访问节点中距离最小的节点
        min_dist = np.inf
        u = -1
        for i in range(n):
            if not visited[i] and distances[i] < min_dist:
                min_dist = distances[i]
                u = i
        
        # 如果找不到可达节点，提前退出
        if u == -1:
            break
            
        visited[u] = True
        
        # 更新邻居节点的距离
        for v in range(n):
            if not visited[v] and adj_matrix[u, v] > 0 and distances[u] + adj_matrix[u, v] < distances[v]:
                distances[v] = distances[u] + adj_matrix[u, v]
    
    return distances

# 构建近邻图并使用Dijkstra算法计算所有点对的最短路径
def all_pairs_dijkstra(dist_matrix, n_neighbors=15):
    """
    为每个节点运行Dijkstra算法，计算所有点对之间的最短路径
    
    参数:
    dist_matrix: 原始距离矩阵
    n_neighbors: 近邻数量
    
    返回:
    shortest_paths: 所有点对之间的最短路径矩阵
    """
    n = dist_matrix.shape[0]
    # 构建近邻图的邻接矩阵
    adj_matrix = np.zeros((n, n))
    # 对每个节点，只保留其n_neighbors个最近邻的连接
    for i in range(n):
        # 获取排序后的索引（从小到大）
        sorted_indices = np.argsort(dist_matrix[i])
        # 取前n_neighbors个近邻（排除自身）
        neighbors = sorted_indices[1:n_neighbors+1]
        adj_matrix[i, neighbors] = dist_matrix[i, neighbors]
    
    # 计算所有点对之间的最短路径
    shortest_paths = np.zeros((n, n))
    for i in range(n):
        shortest_paths[i] = dijkstra(adj_matrix, i)
    
    return shortest_paths

# 经典MDS算法
def mds(dist, n_dims=2):
    """
    实现经典MDS降维
    
    参数:
    dist: 距离平方矩阵，形状为(n_samples, n_samples)
    n_dims: 降维后的维度
    
    返回:
    Z: 降维后的矩阵，形状为(n_samples, n_dims)
    """
    # 步骤1: 获取样本数量
    n = dist.shape[0]
          
    # 步骤2: 构造中心化矩阵H
    H = np.eye(n) - np.ones((n, n)) / n
    
    # 步骤3: 计算双中心化后的内积矩阵B
    B = -0.5 * H @ dist @ H
    
    # 步骤4: 对B进行奇异值分解(SVD)
    U, Sigma, Vt = np.linalg.svd(B)
    Sigma = np.maximum(Sigma, 0)
        
    # 步骤5: 选取前n_components个奇异值和对应的特征向量
    Sigma_k = np.diag(np.sqrt(Sigma[:n_dims]))
    U_k = U[:, :n_dims]
    
    # 步骤6: 计算低维坐标
    Z = U_k @ Sigma_k
    
    return Z

# ISOMAP
def IsoMap(X, n=2, n_neighbors=30):
    # 计算原始距离矩阵
    dist = cal_pairwise_dist(X)
    # 计算所有点对的最短路径（使用Dijkstra算法）
    D_dijkstra = all_pairs_dijkstra(dist, n_neighbors)
    D_dijkstra = D_dijkstra ** 2
    # 应用MDS降维
    data_n = mds(D_dijkstra, n_dims=n)
    return data_n

# 生成数据集
X, color = datasets.make_swiss_roll(n_samples=1500, noise=0.01, random_state=42)

# 应用ISOMAP
data = IsoMap(X, 2, 10)

# 可视化结果
fig = plt.figure(figsize=(14,7))

ax1 = fig.add_subplot(1, 2, 1, projection='3d')
ax1.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)
ax1.set_title("make_swiss_roll")
ax1.view_init(4, -75)  # 调整视角

plt.subplot(122)
plt.title("ISOMAP")
plt.scatter(data[:, 0], data[:, 1], c = color, cmap=plt.cm.Spectral)
plt.show()
~~~



~~~
# sklearn实现
import numpy as np
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.manifold import Isomap

# 生成瑞士卷数据集
X, color = datasets.make_swiss_roll(n_samples=1500, noise=0.01, random_state=42)

# 应用sklearn的ISOMAP降维，默认 Dijkstra 算法
isomap = Isomap(n_neighbors=10, n_components=2)
data = isomap.fit_transform(X)

# 可视化结果
fig = plt.figure(figsize=(14, 7))

# 绘制3D原始数据
ax1 = fig.add_subplot(1, 2, 1, projection='3d')
ax1.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)
ax1.set_title("make_swiss_roll")
ax1.view_init(4, -75)  # 调整视角

# 绘制ISOMAP降维后的2D数据
ax2 = fig.add_subplot(1, 2, 2)
ax2.scatter(data[:, 0], data[:, 1], c=color, cmap=plt.cm.Spectral)
ax2.set_title("ISOMAP")

plt.tight_layout()
plt.show()
~~~

