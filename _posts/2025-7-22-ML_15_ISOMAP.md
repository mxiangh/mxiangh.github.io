---

title: 机器学习（15）等距特征映射——Isometric Mapping, ISOMAP
tags: ML Dimensionality_Reduction
typora-root-url: ./..
---

#### 等距特征映射——Isometric Mapping, ISOMAP

思想：MDS算法在流形结构上的一种应用，也是希望原始空间样本点之间的距离在新空间上保持不变，但是IsoMap使用的是测地距离。

<!--more-->

##### 流行学习——Manifold Learning

1.什么是流形？

流形是局部具有欧几里得空间性质的拓扑空间。换句话说，流形是一个可以在局部范围内近似为欧几里得空间的空间。

- 欧几里得空间（Euclidean space） 是一类特殊的向量空间，它允许讨论长度、夹角等几何性质。

- n维欧几里得空间表示为$\mathbb{R}^n$是由所有n元有序实数元组构成的空间。

二维欧几里得空间$ \mathbb{R}^2$：由所有形如(x,y)的有序对组成，可以表示平面上的所有点。

三维欧几里得空间$ \mathbb{R}^3 $：由所有形如(x,y,z)的有序三元组组成，用于描述物理世界中的空间位置。

- 性质

距离：欧几里得空间中两点的距离可以通过欧几里得距离公式计算$d(\textbf{a},\textbf{b})=\sqrt{\sum_{i=1}^n(a_i-b_i)^2}$

角度：两个向量之间的角度可以通过它们之间的点积和模长来计算$cos\ \theta = \frac{\textbf{a} \cdot \textbf{b}}{\|\textbf{a}\| \|\textbf{b}\|}$

内积空间：欧几里得空间是一个内积空间，其内积定义为两向量的点积

2.什么是流形学习？

流形学习的观点：认为我们所能观察到的数据实际上是由一个低维流形映射到高维空间的。由于数据内部特征的限制，一些高维中的数据会产生维度上的冗余，实际上这些数据只要比较低的维度就能唯一的表示。

流形学习的基本假设是：尽管数据可能在高维空间中呈现，但是它们实际上分布在一个低维的流形上。这个流形是数据的真实结构，它捕捉了数据中的内在关系和模式。

一个形象的流形降维过程如下图。我们有一块卷起来的布，我们希望将其展开到一个二维平面，我们希望展开后的布能够在局部保持布结构的特征，其实也就是将其展开的过程，就想两个人将其拉开一样。

![](/assets/images/ISOMAP/one.png)

##### ISOMAP

1.测地距离

在MDS中，求取距离使用的是欧式距离，但在流形空间上，欧氏距离不一定是数据点之间的真实距离，举个形象的例子就是，二楼有个小明，三楼有个小红，小明要去找小红，不可能用欧式距离飞上三楼，肯定要去爬楼梯绕一圈。

那么小明爬楼找小红所经过的距离，就是测地距离，也就是两个点在先有路径下真实可达的距离（真实距离）。

2.衡量测地距离

测地距离理解了，但是这种距离应该怎么求解？要怎么计算绕一圈的这种路径距离？

这里举一个上课传纸条的例子，你想从最后一排传纸条给第一排的小红，如果你直接走过去或者把纸条扔过去，肯定会被老师发现，所以你想要通过你周围的人将纸条传递过去，你周围的人被称为你的邻居。你传给你的邻居后，你的邻居传给邻居的邻居，最后传到了小红手里，从你到你的邻居再到邻居的邻居，最后到小红，就是一段距离。

你肯定希望传的越快越好，所以你想要找到一条最短的传递路线，这也就是ISOMAP的思想。

班级所有人都可以看成数据点，想要知道任意两个点的测地距离，通过寻找每个点的k个邻居，构造距离矩阵，找到最短的那条路径，就得到了测地距离。

图1蓝色实现是期望实现，图2是ISOMAP实现，图3是降维后的对比。虽然不能完全计算真实距离，但是能近似获取真实距离。

![](/assets/images/ISOMAP/two.png)

![](/assets/images/ISOMAP/three.png)

![](/assets/images/ISOMAP/four.png)

3.图的基础概念

3.1 图

图(Graph)通常表示为:

$$G=(V,E)$$

其中，G表示个图，V是图G中顶点的集合，E是图G中边的集合。

V(G)：顶点的有穷非空集合。

E(G)：顶点之间边的集合。

若$V= \lbrace v_1, v_2,...,v_n \rbrace$，则用|V|表示图G中顶点的个数，也称图G的阶.

$E= \lbrace (u, v) |u∈V, v∈V \rbrace$，用|E|表示图G中边的条数。

3.2 有向图

若E是有向边(也称弧)的有限集合时，则图G为有向图。弧是顶点的有序对，记为<v, w>，其中v,w是顶点，v称为弧尾，w称为弧头，<v,w>称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。

![](/assets/images/ISOMAP/five.png)

图(a)所示的有向图$ G_1$可表示为

$$ G_1 = (V_1,E_1)$$

 $$V 1 = { 1 , 2 , 3 } V_1=\{1,2,3\}$$

$$E_1=\{<1,2>,<2,1>,<2,3>\}$$

3.3无向图

若E是无向边(简称边)的有限集合时，则图G为无向图。边是顶点的无序对，记为(v, w)或(w,v),因为(v,w)=(w,v), 其中v,w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v, w相关联。

![](/assets/images/ISOMAP/six.png)

图(b)所示的无向图$G_2$可表示为

$$G_2=(V_2,E_2)$$

$$V_2=\{1,2,3,4\}$$

$$ E_2=\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}$$

3.4 边的权重

在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图。

3.5 邻接矩阵

设图G有n个顶点，则邻接矩阵A是一个n*n的方阵，定义为:

$$A[i][j] = \left\{\begin{array}{l}
1, \text { 若 }(v_i, v_j)\text {或}<v_i, v_j>\text {是}E(G)\text {中的边} \\
0, \text { 若 }(v_i, v_j)\text {或}<v_i, v_j>\text {不是}E(G)\text {中的边}
\end{array}\right.$$

3.6 带权邻接矩阵

$$A[i][j] = \left\{\begin{array}{l}
W_{ij}, \text { 若 }(v_i, v_j) \in E \text {或} <v_i, v_j> \in E \\
0, \text { 若 } i=j \\
\infty, otherwish
\end{array}\right.$$

4.最短路径算法（只介绍怎么用，因为这是机器学习笔记，不是数据结构笔记）

4.1 Dijkstra算法

Dijkstra（迪杰斯特拉）算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意该算法要求图中不存在负权边。

例子，带权图，找到A与其他点的最短路径：

![](/assets/images/ISOMAP/senven.png)

| 步骤 | S集合（已选节点） | U集合（未选节点） |
| ---- | ----------------- | ----------------- |
| 1 | 从A开始，此时 S= \<A \> <br />此时最短路径A$\to$ A=0<br />以A为中间点，从A开始找 | U=<B、C、D、E、F><br />A $\to$ B=6<br />A $\to$ C=3<br />A $\to$ 其他U中的顶点=$\infty$<br />发现A $\to$ C=3权值为最短 |
| 2 | 选入C，此时 S= <A、C><br />此时最短路径A$\to$ A=0，A$\to$ C=3<br />以C为中间点，从A$\to$ C=3这条最短路径开始找 | U=<B、D、E、F><br />A $\to$ C $\to$ B=5（比上面第一步的A $\to$ B=6短）<br />A $\to$ C $\to$ D=6<br />A $\to$ C $\to$ E=7<br />A $\to$  C $\to$其他U中的顶点=$\infty$<br />发现A $\to$ C $\to$ B=5权值为最短 |
| 3 | 选入B，此时 S= <A、C、B><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5<br />以B为中间点，从A$\to$ C$\to$ B=5这条最短路径开始找 | U=<D、E、F><br />A $\to$ C $\to$ B $\to$ D=10（比上面第二步的A $\to$ C $\to$ D=6长）<br />此时到D的权值改为A $\to$ C $\to$ D=6<br />A $\to$ C $\to$ B $\to$其他U中的顶点=$\infty$<br />发现A $\to$ C $\to$ D=6权值为最短 |
| 4 | 选入D，此时 S= <A、C、B、D><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5，A $\to$ C $\to$ D=6<br />以D为中间点，从A $\to$ C $\to$ D=6这条最短路径开始找 | U=<E、F><br />A $\to$ C $\to$ D $\to$ E=8（比上面第二步的A $\to$ C $\to$ E=7长）<br />此时到E的权值改为A $\to$ C $\to$ E=7<br />A $\to$ C $\to$ D $\to$F=9<br />发现A $\to$ C $\to$ E=7权值为最短 |
| 5 | 选入E，此时 S= <A、C、B、D、E><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5，A $\to$ C $\to$ D=6，A $\to$ C $\to$ E=7<br />以E为中间点，从A $\to$ C $\to$ E=7这条最短路径开始找 | U=<F><br />A $\to$ C $\to$ E $\to$F=12（比上面第四步的A $\to$ C $\to$ D $\to$F=9长）<br />此时到F的权值改为A $\to$ C $\to$ D $\to$F=9<br /> />发现A $\to$ C $\to$ D $\to$F=9权值为最短 |
| 6 | 选入F，此时 S= <A、C、B、D、E、F><br />此时最短路径A$\to$ A=0，A$\to$ C=3，A$\to$ C$\to$ B=5，A $\to$ C $\to$ D=6，A $\to$ C $\to$ E=7、A $\to$ C $\to$ D $\to$F=9 | U集合已空，查找完毕。 |

4.2 Floyd算法

解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题。

思想：从任意节点i到任意节点j的最短路径只有2种可能：1是直接从i到j，2是从i经过若干个节点k到j。

假设$d_{ij}$为节点i到节点j的最短路径的距离，对于每一个节点k，我们检查$d_{ik} + d_{kj} < d_{ij}$是否成立。

如果成立，证明从i到k再到j的路径比i直接到j的路径短，设置$d_{ik} + d_{kj} = d_{ij}$，当遍历完所有节点k，$d_{ij}$中记录的便是i到j的最短路径的距离。

![](/assets/images/ISOMAP/eight.png)

简单解释一下，白色是更新的地方，以第三张图为例，因为允许经过节点1，所以3先到1再到2，便有了距离，以此类推。

